(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{559:function(t,a,e){"use strict";e.r(a);var s=e(6),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"变量对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量对象"}},[t._v("#")]),t._v(" 变量对象")]),t._v(" "),e("h2",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),e("p",[t._v("变量对象（variable object是object）是执行上下文（execution context）相关的数据作用域，存储了上下文中定义的变量和声明的函数。")]),t._v(" "),e("h2",{attrs:{id:"分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),e("p",[t._v("由于不同执行上下文的变量对象稍有不同，因此可分为全局上下文的变量对象和函数上下文的变量对象。")]),t._v(" "),e("ol",[e("li",[t._v("全局上下文的变量对象\n全局上下文中的变量对象也就是我们常说的全局对象。全局对象是预定义的对象，作为js全局函数和全局属性的占位符，包含所有预定义的对象、函数、属性。")]),t._v(" "),e("li",[t._v("函数上下文的变量对象\n函数上下文中的变量对象我们用活动对象表示（active object，AO）变量对象。活动对象和变量对象实际是一个东西，只是变量对象是规范上的实现，不可在js环境下直接访问；而进入函数上下文时，创建了活动对象（AO），因此属性可以被访问。")])]),t._v(" "),e("h2",{attrs:{id:"执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[t._v("#")]),t._v(" 执行过程")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("分析阶段（进入执行上下文）\na. 函数的所有形参（如果该上下文为函数上下文）：无形参是默认为undefined\nb. 函数声明：重复声明时会完全替换已存在的同名函数\nc. 变量声明：重复声明不会影响同名的形参或者函数")])]),t._v(" "),e("li",[e("p",[t._v("执行阶段（代码执行）\n顺序执行代码，并修改活动对象（AO）的值")])])]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("全局上下文的初始化对象是全局对象")])]),t._v(" "),e("li",[e("p",[t._v("函数上下文的初始化对象只包含Arguments对象")])]),t._v(" "),e("li",[e("p",[t._v("进入函数执行上下文时会给变量对象（VO）添加形参、函数声明、变量声明")])]),t._v(" "),e("li",[e("p",[t._v("代码执行是会再次修改变量对象的属性值")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);