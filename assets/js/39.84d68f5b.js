(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{555:function(t,e,s){"use strict";s.r(e);var r=s(6),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("this是函数运行时所在的对象（环境）。\n扩展： ECMAScript中的类型分为语言类型和规范类型。\n语言类型是开发者可以直接使用操作的：String、Number、Boolean、Object、Undefined、null。\n规范类型：是用来用算法描述ECMAScript语言结构和语言类型的：Reference、List、Property Descriptor、Lexical Environment。Reference和this的指向密切相关，具体可参考"),s("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/7",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/mqyqingfeng/Blog/issues/7"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("this常用情况：对象中的方法，事件绑定 ，构造函数 ，定时器，函数对象的call()、apply() 方法；")]),t._v(" "),s("h2",{attrs:{id:"对象中的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象中的方法"}},[t._v("#")]),t._v(" 对象中的方法")]),t._v(" "),s("p",[t._v("this指向取决于函数调用的位置")]),t._v(" "),s("h2",{attrs:{id:"事件绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件绑定"}},[t._v("#")]),t._v(" 事件绑定")]),t._v(" "),s("p",[t._v("this指向取决于函数调用对象")]),t._v(" "),s("h2",{attrs:{id:"定时器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定时器"}},[t._v("#")]),t._v(" 定时器")]),t._v(" "),s("p",[t._v("this指向window全局对象")]),t._v(" "),s("h2",{attrs:{id:"构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[t._v("#")]),t._v(" 构造函数")]),t._v(" "),s("p",[t._v("this指向实例化的对象")]),t._v(" "),s("h2",{attrs:{id:"箭头函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),s("p",[t._v("箭头函数不会创建this，会从上层作用域中继承this；通过apply、call、bind只能传递参数，无法改变this指向。\nPS: 箭头函数特点\n1.this指向由定义时决定，继承上一层作用域且无法改变\n2.箭头函数没有原型\n3.箭头函数不可作为构造函数")])])}),[],!1,null,null,null);e.default=a.exports}}]);