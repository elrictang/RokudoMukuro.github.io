(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{539:function(t,e,r){"use strict";r.r(e);var a=r(6),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h4",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),r("p",[t._v("SOLID原则由五个原则组成，分别是Single Resonsibility Principle(单一职责原则)，Open Closed Principle(开闭原则)，Liskov Substitution Principle(里氏替换原则)，Interface Segregation Principle(接口隔离原则)， Dependency Inversion Pripciple  (依赖反转原则)")]),t._v(" "),r("h4",{attrs:{id:"srp单一职责原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#srp单一职责原则"}},[t._v("#")]),t._v(" SRP单一职责原则")]),t._v(" "),r("p",[t._v("一个类只负责完成一个职责或者功能，目的是实现代码的高内聚、低耦合，提高代码的复用、可读和可维护性；\n如何判断类的职责是否单一")]),t._v(" "),r("ul",[r("li",[t._v("类中的代码行数、函数、属性过多")]),t._v(" "),r("li",[t._v("类依赖的其他类或者依赖类的其他类过多")]),t._v(" "),r("li",[t._v("私有方法过多")]),t._v(" "),r("li",[t._v("大量放大都操作类中的某几个属性")])]),t._v(" "),r("h4",{attrs:{id:"ocp开闭原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ocp开闭原则"}},[t._v("#")]),t._v(" OCP开闭原则")]),t._v(" "),r("p",[t._v("本质就是扩展性，即对扩展开放，对修改关闭；\n添加一个新功能时，应该是再已有代码基础上扩展代码，而非修改已有代码（修改模块、类、方法、属性）的方式来完成。")]),t._v(" "),r("h4",{attrs:{id:"lsp里氏替换原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lsp里氏替换原则"}},[t._v("#")]),t._v(" LSP里氏替换原则")]),t._v(" "),r("p",[t._v("子类的对象能够替换程序中父类出现的任何地方，并保证原来程序的逻辑性不变且正确性不被破坏。")]),t._v(" "),r("blockquote",[r("p",[t._v("和多态区别: 多态是面向对象的一种特性，而LSP是一种设计原则，用来指导继承关系中子类如何设计，子类的设计要保证替换父类的时候不改变原程序的逻辑。")])]),t._v(" "),r("h4",{attrs:{id:"isp接口隔离原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#isp接口隔离原则"}},[t._v("#")]),t._v(" ISP接口隔离原则")]),t._v(" "),r("p",[t._v("一组API接口集合: 如果某个接口只能被单个调用者使用，我们需要把这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不需要的接口；\n单个API接口或函数：如果部分调用者只需要函数中的部分功能，那就需要把函数拆分成粒度更细的多个函数；\nOOP中的接口概念：接口的设计要尽量单一，不要让接口的实现和调用者依赖不需要的函数；")]),t._v(" "),r("blockquote",[r("p",[t._v("单一职责原则针对的是模块、类、接口的设计；接口隔离原则更侧重接口的设计，提供了一种判断接口是否单一的标准（通过调用者如何使用接口间接判断）")])]),t._v(" "),r("h4",{attrs:{id:"dip依赖反转原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dip依赖反转原则"}},[t._v("#")]),t._v(" DIP依赖反转原则")]),t._v(" "),r("ol",[r("li",[t._v("控制反转（Inversion of Control）: 框架提供可扩展的代码骨架，整个程序的执行流程可以通过框架进行控制；因此使用框架之后，程序流程的执行从编码反转到了框架。")]),t._v(" "),r("li",[t._v("依赖注入（Dependency Injection）: 不在类内部通过new的方式创建依赖类对象，而是通过将依赖的类实例再外部创建好之后，通过类的构造函数或者函数参数的形式传递给类使用")]),t._v(" "),r("li",[t._v("依赖注入框架（Dependency Injection Framework）:类对象的创建和依赖注入在实际开发中大量的类情况下会变得十分复杂，依赖注入框架可以使用框架替换手动编码，实现自动创建对象，管理对象的生命周期，依赖注入等行为；")]),t._v(" "),r("li",[t._v("依赖反转原则（Dependency Inversion Priciple）: 跟控制反转有点类似，主要用来指导框架层面的设计；高层模块不依赖低层模块，它们共同依赖于同一个对象。以tomcat运行java web代码为例，tomcat就是高层模块，web应用程序就是低层模块，tomcat和应用程序之间没有直接的依赖关系，但是都依赖servlert规范")])])])}),[],!1,null,null,null);e.default=s.exports}}]);